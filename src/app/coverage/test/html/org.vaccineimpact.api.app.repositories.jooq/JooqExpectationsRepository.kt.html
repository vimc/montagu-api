<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JooqExpectationsRepository.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">app</a> &gt; <a href="index.source.html" class="el_package">org.vaccineimpact.api.app.repositories.jooq</a> &gt; <span class="el_source">JooqExpectationsRepository.kt</span></div><h1>JooqExpectationsRepository.kt</h1><pre class="source lang-java linenums">package org.vaccineimpact.api.app.repositories.jooq

import org.jooq.DSLContext
import org.jooq.JoinType
import org.jooq.Record
import org.vaccineimpact.api.app.errors.DatabaseContentsError
import org.vaccineimpact.api.app.errors.UnknownObjectError
import org.vaccineimpact.api.app.repositories.ExpectationsRepository
import org.vaccineimpact.api.db.Tables.*
import org.vaccineimpact.api.db.fieldsAsList
import org.vaccineimpact.api.db.fromJoinPath
import org.vaccineimpact.api.db.joinPath
import org.vaccineimpact.api.db.tables.BurdenEstimateCountryExpectation
import org.vaccineimpact.api.db.tables.BurdenEstimateExpectation
import org.vaccineimpact.api.db.tables.BurdenEstimateOutcomeExpectation
import org.vaccineimpact.api.db.tables.records.BurdenEstimateExpectationRecord
import org.vaccineimpact.api.models.*
import org.vaccineimpact.api.models.expectations.*

<span class="nc" id="L20">data class ApplicableScenariosAndDisease(val scenarios: List&lt;String&gt;, val disease: String)</span>

<span class="nc" id="L22">class JooqExpectationsRepository(dsl: DSLContext)</span>
<span class="nc" id="L23">    : JooqRepository(dsl), ExpectationsRepository</span>
{

<span class="nc" id="L26">    private object Tables</span>
    {
<span class="nc" id="L28">        val expectations: BurdenEstimateExpectation = BURDEN_ESTIMATE_EXPECTATION</span>
<span class="nc" id="L29">        val countries: BurdenEstimateCountryExpectation = BURDEN_ESTIMATE_COUNTRY_EXPECTATION</span>
<span class="nc" id="L30">        val outcomes: BurdenEstimateOutcomeExpectation = BURDEN_ESTIMATE_OUTCOME_EXPECTATION</span>
    }

    override fun getExpectationIdsForGroupAndTouchstone(groupId: String, touchstoneVersionId: String): List&lt;Int&gt;
    {
<span class="nc" id="L35">        return dsl.select(Tables.expectations.ID)</span>
<span class="nc" id="L36">                .fromJoinPath(Tables.expectations, RESPONSIBILITY, RESPONSIBILITY_SET, MODELLING_GROUP)</span>
<span class="nc" id="L37">                .join(TOUCHSTONE)</span>
<span class="nc" id="L38">                .on(TOUCHSTONE.ID.eq(RESPONSIBILITY_SET.TOUCHSTONE))</span>
<span class="nc" id="L39">                .where(TOUCHSTONE.ID.eq(touchstoneVersionId))</span>
<span class="nc" id="L40">                .and(MODELLING_GROUP.ID.eq(groupId))</span>
<span class="nc" id="L41">                .fetchInto(Int::class.java)</span>
    }

    override fun getExpectationsForResponsibility(responsibilityId: Int): ExpectationMapping
    {
<span class="nc" id="L46">        val id = dsl.select(RESPONSIBILITY.EXPECTATIONS)</span>
<span class="nc" id="L47">                .from(RESPONSIBILITY)</span>
<span class="nc" id="L48">                .where(RESPONSIBILITY.ID.eq(responsibilityId))</span>
<span class="nc" id="L49">                .fetchOne()</span>
<span class="nc bnc" id="L50" title="All 2 branches missed.">                .value1()</span>
<span class="nc" id="L51">                ?: throw UnknownObjectError(responsibilityId, &quot;burden-estimate-expectation&quot;)</span>

<span class="nc" id="L53">        return getExpectationsById(id)</span>
    }

    override fun getExpectationsById(expectationsId: Int): ExpectationMapping
    {
<span class="nc" id="L58">        val basicData = dsl.fetchAny(Tables.expectations, Tables.expectations.ID.eq(expectationsId))</span>
<span class="nc" id="L59">        val expectations = basicData.withCountriesAndOutcomes()</span>
<span class="nc" id="L60">        val scenarioRecords = dsl.select(SCENARIO_DESCRIPTION.ID, SCENARIO_DESCRIPTION.DISEASE)</span>
<span class="nc" id="L61">                .fromJoinPath(RESPONSIBILITY, SCENARIO, SCENARIO_DESCRIPTION)</span>
<span class="nc" id="L62">                .where(RESPONSIBILITY.EXPECTATIONS.eq(expectationsId))</span>
<span class="nc" id="L63">                .fetch()</span>
<span class="nc" id="L64">        val (scenarios, disease) = getMappingInfoFromRecords(scenarioRecords, expectationsId)</span>
<span class="nc" id="L65">        return ExpectationMapping(expectations, scenarios, disease)</span>
    }

    override fun getExpectationsForResponsibilitySet(modellingGroup: String, touchstoneVersion: String): List&lt;ExpectationMapping&gt;
    {
<span class="nc" id="L70">        return dsl.select(Tables.expectations.fieldsAsList())</span>
<span class="nc" id="L71">                .select(SCENARIO_DESCRIPTION.ID, SCENARIO_DESCRIPTION.DISEASE)</span>
<span class="nc" id="L72">                .fromJoinPath(RESPONSIBILITY_SET, RESPONSIBILITY, Tables.expectations)</span>
<span class="nc" id="L73">                .joinPath(RESPONSIBILITY, SCENARIO, SCENARIO_DESCRIPTION)</span>
<span class="nc" id="L74">                .where(</span>
<span class="nc" id="L75">                        RESPONSIBILITY_SET.TOUCHSTONE.eq(touchstoneVersion)</span>
<span class="nc" id="L76">                                .and(RESPONSIBILITY_SET.MODELLING_GROUP.eq(modellingGroup))</span>
                )
<span class="nc" id="L78">                .groupBy { it[Tables.expectations.ID] }</span>
<span class="nc" id="L79">                .map { getBasicDataAndMappingFromRecords(it.value) }</span>
<span class="nc" id="L80">                .map { (basicData, mapping) -&gt;</span>
<span class="nc" id="L81">                    ExpectationMapping(</span>
<span class="nc" id="L82">                            basicData.withCountriesAndOutcomes(),</span>
<span class="nc" id="L83">                            mapping.scenarios,</span>
<span class="nc" id="L84">                            mapping.disease</span>
<span class="nc" id="L85">                    )</span>
                }
    }

    override fun getAllExpectations(): List&lt;TouchstoneModelExpectations&gt;
    {
<span class="nc" id="L91">        val records = dsl.select(</span>
<span class="nc" id="L92">                SCENARIO_DESCRIPTION.DISEASE,</span>
<span class="nc" id="L93">                TOUCHSTONE.ID,</span>
<span class="nc" id="L94">                RESPONSIBILITY_SET.MODELLING_GROUP,</span>
<span class="nc" id="L95">                *BURDEN_ESTIMATE_EXPECTATION.fields(),</span>
<span class="nc" id="L96">                SCENARIO.SCENARIO_DESCRIPTION,</span>
<span class="nc" id="L97">                BURDEN_OUTCOME.CODE,</span>
<span class="nc" id="L98">                BURDEN_OUTCOME.NAME)</span>
<span class="nc" id="L99">                .fromJoinPath(RESPONSIBILITY, BURDEN_ESTIMATE_EXPECTATION)</span>
<span class="nc" id="L100">                .joinPath(RESPONSIBILITY, SCENARIO, SCENARIO_DESCRIPTION)</span>
<span class="nc" id="L101">                .joinPath(RESPONSIBILITY, RESPONSIBILITY_SET, TOUCHSTONE)</span>
<span class="nc" id="L102">                .joinPath(BURDEN_ESTIMATE_EXPECTATION, Tables.outcomes, joinType = JoinType.LEFT_OUTER_JOIN)</span>
<span class="nc" id="L103">                .leftJoin(BURDEN_OUTCOME)</span>
<span class="nc" id="L104">                .on(Tables.outcomes.OUTCOME.eq(BURDEN_OUTCOME.CODE))</span>
<span class="nc" id="L105">                .where(RESPONSIBILITY.IS_OPEN.eq(true))</span>
<span class="nc" id="L106">                .and(TOUCHSTONE.STATUS.eq(&quot;open&quot;))</span>
<span class="nc" id="L107">                .and(SCENARIO.TOUCHSTONE.eq(RESPONSIBILITY_SET.TOUCHSTONE))</span>
<span class="nc" id="L108">                .orderBy(RESPONSIBILITY_SET.MODELLING_GROUP, SCENARIO_DESCRIPTION.DISEASE, TOUCHSTONE.ID)</span>

<span class="nc" id="L110">        val outcomes = records.groupBy{ it[BURDEN_ESTIMATE_EXPECTATION.ID] }</span>
<span class="nc" id="L111">            .mapValues{</span>
<span class="nc" id="L112">                it.value.mapNotNull{ row -&gt;</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">                            if (row[BURDEN_OUTCOME.CODE] == null)</span>
                            {
<span class="nc" id="L115">                                null</span>
                            }
                            else
                            {
<span class="nc" id="L119">                                Outcome(row[BURDEN_OUTCOME.CODE], row[BURDEN_OUTCOME.NAME])</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">                            }</span>
<span class="nc" id="L121">                        }.distinct()</span>
            }

<span class="nc" id="L124">        val scenarios = records.groupBy{ it[BURDEN_ESTIMATE_EXPECTATION.ID] }</span>
<span class="nc" id="L125">                .mapValues{</span>
<span class="nc" id="L126">                    it.value.map{ row -&gt; row[SCENARIO.SCENARIO_DESCRIPTION]}.distinct()</span>
                }

<span class="nc" id="L129">        return records.groupBy{it[BURDEN_ESTIMATE_EXPECTATION.ID]}</span>
<span class="nc" id="L130">                .map{</span>
<span class="nc" id="L131">                    val fields = it.value.first()</span>
<span class="nc" id="L132">                    TouchstoneModelExpectations(</span>
<span class="nc" id="L133">                            fields[TOUCHSTONE.ID], fields[RESPONSIBILITY_SET.MODELLING_GROUP],</span>
<span class="nc" id="L134">                            fields[SCENARIO_DESCRIPTION.DISEASE],</span>
<span class="nc" id="L135">                            fields.into(BurdenEstimateExpectationRecord::class.java)</span>
<span class="nc" id="L136">                                    .toOutcomeExpectations(outcomes[it.key]!!),</span>
<span class="nc" id="L137">                            scenarios[it.key]!!)</span>
                }
    }

    private fun getBasicDataAndMappingFromRecords(records: List&lt;Record&gt;): Pair&lt;BurdenEstimateExpectationRecord, ApplicableScenariosAndDisease&gt;
    {
<span class="nc" id="L143">        val basicData = records.first().into(BurdenEstimateExpectationRecord::class.java)</span>
<span class="nc" id="L144">        val mappingInfo = getMappingInfoFromRecords(records, basicData.id)</span>
<span class="nc" id="L145">        return Pair(basicData, mappingInfo)</span>
    }

    private fun getMappingInfoFromRecords(records: List&lt;Record&gt;, expectationsId: Int?): ApplicableScenariosAndDisease
    {
<span class="nc" id="L150">        val scenarios = records.map { it[SCENARIO_DESCRIPTION.ID] }.distinct().sorted()</span>
<span class="nc" id="L151">        val diseases = records.map { it[SCENARIO_DESCRIPTION.DISEASE] }.distinct()</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">        val disease = diseases.singleOrNull()</span>
<span class="nc" id="L153">                ?: throw DatabaseContentsError(&quot;CountryOutcomeExpectations $expectationsId is used by responsibilities that do not all share the same disease: ${diseases.joinToString()}&quot;)</span>
<span class="nc" id="L154">        return ApplicableScenariosAndDisease(scenarios, disease)</span>
    }

    private fun BurdenEstimateExpectationRecord.toOutcomeExpectations(outcomes: List&lt;Outcome&gt;): OutcomeExpectations
    {
<span class="nc" id="L159">        val record = this</span>
<span class="nc" id="L160">        return OutcomeExpectations(</span>
<span class="nc" id="L161">                record.id,</span>
<span class="nc" id="L162">                record.description,</span>
<span class="nc" id="L163">                record.yearMinInclusive..record.yearMaxInclusive,</span>
<span class="nc" id="L164">                record.ageMinInclusive..record.ageMaxInclusive,</span>
<span class="nc" id="L165">                CohortRestriction(record.cohortMinInclusive, record.cohortMaxInclusive),</span>
<span class="nc" id="L166">                outcomes.sortedBy { it.code }</span>
        )
    }

    private fun BurdenEstimateExpectationRecord.withCountriesAndOutcomes(): CountryOutcomeExpectations
    {
<span class="nc" id="L172">        val record = this</span>
<span class="nc" id="L173">        val countries = getCountries(record)</span>
<span class="nc" id="L174">        val outcomes = getOutcomes(record)</span>
<span class="nc" id="L175">        return CountryOutcomeExpectations(</span>
<span class="nc" id="L176">                record.id,</span>
<span class="nc" id="L177">                record.description,</span>
<span class="nc" id="L178">                record.yearMinInclusive..record.yearMaxInclusive,</span>
<span class="nc" id="L179">                record.ageMinInclusive..record.ageMaxInclusive,</span>
<span class="nc" id="L180">                CohortRestriction(record.cohortMinInclusive, record.cohortMaxInclusive),</span>
<span class="nc" id="L181">                countries,</span>
<span class="nc" id="L182">                outcomes</span>
        )
    }

    private fun getOutcomes(basicData: BurdenEstimateExpectationRecord): List&lt;Outcome&gt;
    {
<span class="nc" id="L188">        return dsl.select(BURDEN_OUTCOME.CODE, BURDEN_OUTCOME.NAME)</span>
<span class="nc" id="L189">                .from(Tables.outcomes)</span>
<span class="nc" id="L190">                .join(BURDEN_OUTCOME)</span>
<span class="nc" id="L191">                .on(Tables.outcomes.OUTCOME.eq(BURDEN_OUTCOME.CODE))</span>
<span class="nc" id="L192">                .where(Tables.outcomes.BURDEN_ESTIMATE_EXPECTATION.eq(basicData.id))</span>
<span class="nc" id="L193">                .fetchInto(Outcome::class.java)</span>
<span class="nc" id="L194">                .toList()</span>
    }

    private fun getCountries(basicData: BurdenEstimateExpectationRecord): List&lt;Country&gt;
    {
<span class="nc" id="L199">        return dsl.select(COUNTRY.ID, COUNTRY.NAME)</span>
<span class="nc" id="L200">                .fromJoinPath(Tables.countries, COUNTRY)</span>
<span class="nc" id="L201">                .where(Tables.countries.BURDEN_ESTIMATE_EXPECTATION.eq(basicData.id))</span>
<span class="nc" id="L202">                .orderBy(COUNTRY.ID)</span>
<span class="nc" id="L203">                .fetchInto(Country::class.java)</span>
<span class="nc" id="L204">                .toList()</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>