<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JooqBurdenEstimateRepository.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">app</a> &gt; <a href="index.source.html" class="el_package">org.vaccineimpact.api.app.repositories.jooq</a> &gt; <span class="el_source">JooqBurdenEstimateRepository.kt</span></div><h1>JooqBurdenEstimateRepository.kt</h1><pre class="source lang-java linenums">package org.vaccineimpact.api.app.repositories.jooq

import org.jooq.DSLContext
import org.jooq.JoinType
import org.jooq.impl.DSL.sum
import org.vaccineimpact.api.app.errors.BadRequest
import org.vaccineimpact.api.app.errors.InvalidOperationError
import org.vaccineimpact.api.app.errors.UnknownObjectError
import org.vaccineimpact.api.app.models.BurdenEstimateOutcome
import org.vaccineimpact.api.app.repositories.BurdenEstimateRepository
import org.vaccineimpact.api.app.repositories.ModellingGroupRepository
import org.vaccineimpact.api.app.repositories.ScenarioRepository
import org.vaccineimpact.api.app.repositories.TouchstoneRepository
import org.vaccineimpact.api.app.repositories.burdenestimates.BurdenEstimateWriter
import org.vaccineimpact.api.app.repositories.burdenestimates.CentralBurdenEstimateWriter
import org.vaccineimpact.api.app.repositories.burdenestimates.StochasticBurdenEstimateWriter
import org.vaccineimpact.api.app.repositories.jooq.mapping.BurdenMappingHelper
import org.vaccineimpact.api.db.Tables.*
import org.vaccineimpact.api.db.fromJoinPath
import org.vaccineimpact.api.db.joinPath
import org.vaccineimpact.api.models.*
import org.vaccineimpact.api.serialization.FlexibleDataTable
import java.beans.ConstructorProperties
import java.sql.Timestamp
import java.time.Instant
import org.vaccineimpact.api.db.Tables
import org.vaccineimpact.api.db.fetchSequence
import org.vaccineimpact.api.db.tables.records.BurdenEstimateRecord
import org.vaccineimpact.api.models.expectations.RowLookup

data class ResponsibilityInfo
@ConstructorProperties(&quot;id&quot;, &quot;disease&quot;, &quot;status&quot;, &quot;setId&quot;)
<span class="pc" id="L33">constructor(val id: Int, val disease: String, val setStatus: String, val setId: Int)</span>

<span class="nc" id="L35">class JooqBurdenEstimateRepository(</span>
        dsl: DSLContext,
        private val scenarioRepository: ScenarioRepository,
<span class="nc" id="L38">        override val touchstoneRepository: TouchstoneRepository,</span>
        private val modellingGroupRepository: ModellingGroupRepository,
        private val mapper: BurdenMappingHelper = BurdenMappingHelper(),
        centralBurdenEstimateWriter: CentralBurdenEstimateWriter? = null,
        stochasticBurdenEstimateWriter: StochasticBurdenEstimateWriter? = null
<span class="nc" id="L43">) : JooqRepository(dsl), BurdenEstimateRepository</span>
{
    override fun getEstimates(setId: Int, responsibilityId: Int,
                              outcomeIds: List&lt;Short&gt;,
                              burdenEstimateGrouping: BurdenEstimateGrouping):
            BurdenEstimateDataSeries
    {
        // check set belongs to this responsibility
<span class="nc" id="L51">        dsl.select()</span>
<span class="nc" id="L52">                .from(BURDEN_ESTIMATE_SET)</span>
<span class="nc" id="L53">                .where(BURDEN_ESTIMATE_SET.RESPONSIBILITY.eq(responsibilityId))</span>
<span class="nc" id="L54">                .and(BURDEN_ESTIMATE_SET.ID.eq(setId))</span>
<span class="nc bnc" id="L55" title="All 2 branches missed.">                .singleOrNull()</span>
<span class="nc" id="L56">                ?: throw UnknownObjectError(setId, BurdenEstimateSet::class)</span>

<span class="nc" id="L58">        val data = dsl.select(BURDEN_ESTIMATE.YEAR, BURDEN_ESTIMATE.AGE, sum(BURDEN_ESTIMATE.VALUE).`as`(&quot;value&quot;))</span>
<span class="nc" id="L59">                .from(BURDEN_ESTIMATE)</span>
<span class="nc" id="L60">                .where(BURDEN_ESTIMATE.BURDEN_ESTIMATE_SET.eq(setId))</span>
<span class="nc" id="L61">                .and(BURDEN_ESTIMATE.BURDEN_OUTCOME.`in`(outcomeIds))</span>
<span class="nc" id="L62">                .groupBy(BURDEN_ESTIMATE.YEAR, BURDEN_ESTIMATE.AGE)</span>
<span class="nc" id="L63">                .orderBy(BURDEN_ESTIMATE.YEAR, BURDEN_ESTIMATE.AGE)</span>
<span class="nc" id="L64">                .fetchInto(BurdenEstimateDataPoint::class.java)</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">                .groupBy { if (burdenEstimateGrouping == BurdenEstimateGrouping.AGE) it.age else it.year }</span>

<span class="nc" id="L67">        return BurdenEstimateDataSeries(burdenEstimateGrouping, data)</span>
    }

    override fun getBurdenOutcomeIds(matching: String): List&lt;Short&gt;
    {
<span class="nc" id="L72">        return dsl.select(BURDEN_OUTCOME.ID)</span>
<span class="nc" id="L73">                .from(BURDEN_OUTCOME)</span>
<span class="nc" id="L74">                .where(BURDEN_OUTCOME.CODE.like(&quot;%$matching%&quot;))</span>
<span class="nc" id="L75">                .fetchInto(Short::class.java)</span>
    }

<span class="nc" id="L78">    private fun getCountriesAsLookup(): Map&lt;Short, String&gt; = dsl.select(Tables.COUNTRY.ID, Tables.COUNTRY.NID)</span>
<span class="nc" id="L79">            .from(Tables.COUNTRY)</span>
<span class="nc" id="L80">            .fetch()</span>
<span class="nc" id="L81">            .intoMap(Tables.COUNTRY.NID, Tables.COUNTRY.ID)</span>

    override fun validateEstimates(set: BurdenEstimateSet, expectedRowMap: RowLookup): RowLookup
    {
<span class="nc" id="L85">        val countries = getCountriesAsLookup()</span>
<span class="nc" id="L86">        dsl.select(BURDEN_ESTIMATE.COUNTRY, BURDEN_ESTIMATE.AGE, BURDEN_ESTIMATE.YEAR)</span>
<span class="nc" id="L87">                .from(BURDEN_ESTIMATE)</span>
<span class="nc" id="L88">                .where(BURDEN_ESTIMATE.BURDEN_ESTIMATE_SET.eq(set.id)).stream().use { stream -&gt;</span>
<span class="nc" id="L89">                    stream.forEach { validate(it.into(BURDEN_ESTIMATE), countries, expectedRowMap) }</span>
<span class="nc" id="L90">                }</span>

<span class="nc" id="L92">        return expectedRowMap</span>
    }

    private fun validate(r: BurdenEstimateRecord, countries: Map&lt;Short, String&gt;, expectedRows: RowLookup)
    {
<span class="nc" id="L97">        val countryId = countries[r.country]</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">        val ages = expectedRows[countryId]</span>
<span class="nc" id="L99">                ?: throw BadRequest(&quot;We are not expecting data for country $countryId&quot;)</span>

<span class="nc bnc" id="L101" title="All 2 branches missed.">        val years = ages[r.age]</span>
<span class="nc" id="L102">                ?: throw BadRequest(&quot;We are not expecting data for age ${r.age}&quot;)</span>

<span class="nc bnc" id="L104" title="All 2 branches missed.">        if (!years.containsKey(r.year))</span>
        {
<span class="nc" id="L106">            throw BadRequest(&quot;We are not expecting data for age ${r.age} and year ${r.year}&quot;)</span>
        }

<span class="nc" id="L109">        expectedRows[countryId]!![r.age]!![r.year] = true</span>
<span class="nc" id="L110">    }</span>

<span class="nc bnc" id="L112" title="All 2 branches missed.">    private val centralBurdenEstimateWriter: BurdenEstimateWriter = centralBurdenEstimateWriter</span>
<span class="nc" id="L113">            ?: CentralBurdenEstimateWriter(dsl)</span>

<span class="nc bnc" id="L115" title="All 2 branches missed.">    private val stochasticBurdenEstimateWriter: StochasticBurdenEstimateWriter = stochasticBurdenEstimateWriter</span>
<span class="nc" id="L116">            ?: StochasticBurdenEstimateWriter(dsl)</span>

    override fun getModelRunParameterSets(groupId: String, touchstoneVersionId: String): List&lt;ModelRunParameterSet&gt;
    {
        // Dereference modelling group IDs
<span class="nc" id="L121">        val modellingGroup = modellingGroupRepository.getModellingGroup(groupId)</span>
<span class="nc" id="L122">        val setId = getResponsibilitySetId(groupId, touchstoneVersionId)</span>

<span class="nc" id="L124">        return dsl.select(</span>
<span class="nc" id="L125">                MODEL_RUN_PARAMETER_SET.ID,</span>
<span class="nc" id="L126">                MODEL.ID.`as`(&quot;model&quot;),</span>
<span class="nc" id="L127">                UPLOAD_INFO.UPLOADED_BY,</span>
<span class="nc" id="L128">                UPLOAD_INFO.UPLOADED_ON,</span>
<span class="nc" id="L129">                MODEL.DISEASE)</span>
<span class="nc" id="L130">                .fromJoinPath(MODEL_RUN_PARAMETER_SET, UPLOAD_INFO)</span>
<span class="nc" id="L131">                .join(MODEL)</span>
<span class="nc" id="L132">                .on(MODEL.CURRENT_VERSION.eq(MODEL_RUN_PARAMETER_SET.MODEL_VERSION))</span>
<span class="nc" id="L133">                .where(MODEL.MODELLING_GROUP.eq(modellingGroup.id))</span>
<span class="nc" id="L134">                .and(MODEL.IS_CURRENT)</span>
<span class="nc" id="L135">                .and(MODEL_RUN_PARAMETER_SET.RESPONSIBILITY_SET.eq(setId))</span>
<span class="nc" id="L136">                .orderBy(MODEL.DISEASE.asc(), UPLOAD_INFO.UPLOADED_ON.desc())</span>
<span class="nc" id="L137">                .fetchInto(ModelRunParameterSet::class.java)</span>
    }

    override fun checkModelRunParameterSetExists(modelRunParameterSetId: Int, groupId: String, touchstoneVersionId: String)
    {
        //Check that the parameter set exists and belongs to the specified group and touchstone
<span class="nc" id="L143">        getModelRunParameterSets(groupId, touchstoneVersionId)</span>
<span class="nc bnc" id="L144" title="All 4 branches missed.">                .filter { s -&gt; s.id == modelRunParameterSetId }</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">                .firstOrNull() ?: throw UnknownObjectError(modelRunParameterSetId, ModelRunParameterSet::class)</span>
<span class="nc" id="L146">    }</span>

    override fun getBurdenEstimateSetForResponsibility(setId: Int, responsibilityId: Int): BurdenEstimateSet
    {
<span class="nc" id="L150">        val table = BURDEN_ESTIMATE_SET</span>
<span class="nc" id="L151">        val records = dsl.select(</span>
<span class="nc" id="L152">                table.ID,</span>
<span class="nc" id="L153">                table.UPLOADED_ON,</span>
<span class="nc" id="L154">                table.UPLOADED_BY,</span>
<span class="nc" id="L155">                table.SET_TYPE,</span>
<span class="nc" id="L156">                table.SET_TYPE_DETAILS,</span>
<span class="nc" id="L157">                table.STATUS,</span>
<span class="nc" id="L158">                table.RESPONSIBILITY,</span>
<span class="nc" id="L159">                table.ORIGINAL_FILENAME,</span>
<span class="nc" id="L160">                BURDEN_ESTIMATE_SET_PROBLEM.PROBLEM</span>
        )
<span class="nc" id="L162">                .from(table)</span>
<span class="nc" id="L163">                .joinPath(table, BURDEN_ESTIMATE_SET_PROBLEM, joinType = JoinType.LEFT_OUTER_JOIN)</span>
<span class="nc" id="L164">                .where(table.ID.eq(setId).and(table.RESPONSIBILITY.eq(responsibilityId)))</span>
<span class="nc" id="L165">                .fetch()</span>

<span class="nc bnc" id="L167" title="All 2 branches missed.">        return mapper.mapBurdenEstimateSets(records).singleOrNull()</span>
<span class="nc" id="L168">                ?: throw UnknownObjectError(setId, &quot;burden-estimate-set&quot;)</span>
    }

    override fun getBurdenEstimateSet(groupId: String, touchstoneVersionId: String, scenarioId: String,
                                      burdenEstimateSetId: Int): BurdenEstimateSet
    {
<span class="nc" id="L174">        val table = BURDEN_ESTIMATE_SET</span>
<span class="nc" id="L175">        val records = dsl.select(</span>
<span class="nc" id="L176">                table.ID,</span>
<span class="nc" id="L177">                table.UPLOADED_ON,</span>
<span class="nc" id="L178">                table.UPLOADED_BY,</span>
<span class="nc" id="L179">                table.SET_TYPE,</span>
<span class="nc" id="L180">                table.SET_TYPE_DETAILS,</span>
<span class="nc" id="L181">                table.STATUS,</span>
<span class="nc" id="L182">                table.ORIGINAL_FILENAME,</span>
<span class="nc" id="L183">                BURDEN_ESTIMATE_SET_PROBLEM.PROBLEM</span>
        )
<span class="nc" id="L185">                .from(table)</span>
<span class="nc" id="L186">                .join(RESPONSIBILITY)</span>
<span class="nc" id="L187">                .on(RESPONSIBILITY.ID.eq(table.RESPONSIBILITY))</span>
<span class="nc" id="L188">                .joinPath(RESPONSIBILITY, SCENARIO, SCENARIO_DESCRIPTION)</span>
<span class="nc" id="L189">                .joinPath(RESPONSIBILITY, RESPONSIBILITY_SET)</span>
<span class="nc" id="L190">                .joinPath(table, BURDEN_ESTIMATE_SET_PROBLEM, joinType = JoinType.LEFT_OUTER_JOIN)</span>
<span class="nc" id="L191">                .where(table.ID.eq(burdenEstimateSetId))</span>
<span class="nc" id="L192">                .and(RESPONSIBILITY_SET.MODELLING_GROUP.eq(groupId))</span>
<span class="nc" id="L193">                .and(RESPONSIBILITY_SET.TOUCHSTONE.eq(touchstoneVersionId))</span>
<span class="nc" id="L194">                .and(SCENARIO_DESCRIPTION.ID.eq(scenarioId))</span>
<span class="nc" id="L195">                .fetch()</span>

<span class="nc bnc" id="L197" title="All 2 branches missed.">        return mapper.mapBurdenEstimateSets(records).singleOrNull()</span>
<span class="nc" id="L198">                ?: throw UnknownObjectError(burdenEstimateSetId, BurdenEstimateSet::class)</span>
    }

    override fun getBurdenEstimateSets(groupId: String, touchstoneVersionId: String, scenarioId: String): List&lt;BurdenEstimateSet&gt;
    {
        // Dereference modelling group IDs
<span class="nc" id="L204">        val modellingGroup = modellingGroupRepository.getModellingGroup(groupId)</span>
<span class="nc" id="L205">        val table = BURDEN_ESTIMATE_SET</span>
<span class="nc" id="L206">        val records = dsl.select(</span>
<span class="nc" id="L207">                table.ID,</span>
<span class="nc" id="L208">                table.UPLOADED_ON,</span>
<span class="nc" id="L209">                table.UPLOADED_BY,</span>
<span class="nc" id="L210">                table.SET_TYPE,</span>
<span class="nc" id="L211">                table.SET_TYPE_DETAILS,</span>
<span class="nc" id="L212">                table.STATUS,</span>
<span class="nc" id="L213">                table.ORIGINAL_FILENAME,</span>
<span class="nc" id="L214">                BURDEN_ESTIMATE_SET_PROBLEM.PROBLEM</span>
        )
<span class="nc" id="L216">                .from(table)</span>
<span class="nc" id="L217">                .joinPath(table, BURDEN_ESTIMATE_SET_PROBLEM, joinType = JoinType.LEFT_OUTER_JOIN)</span>
<span class="nc" id="L218">                .join(RESPONSIBILITY).on(RESPONSIBILITY.ID.eq(table.RESPONSIBILITY))</span>
<span class="nc" id="L219">                .joinPath(RESPONSIBILITY, RESPONSIBILITY_SET, MODELLING_GROUP)</span>
<span class="nc" id="L220">                .joinPath(RESPONSIBILITY, SCENARIO, SCENARIO_DESCRIPTION)</span>
<span class="nc" id="L221">                .where(SCENARIO_DESCRIPTION.ID.eq(scenarioId))</span>
<span class="nc" id="L222">                .and(RESPONSIBILITY_SET.TOUCHSTONE.eq(touchstoneVersionId))</span>
<span class="nc" id="L223">                .and(MODELLING_GROUP.ID.eq(modellingGroup.id))</span>
<span class="nc" id="L224">                .fetch()</span>

<span class="nc" id="L226">        return mapper.mapBurdenEstimateSets(records)</span>
    }

    override fun getBurdenEstimateOutcomesSequence(groupId: String, touchstoneVersionId: String, scenarioId: String, burdenEstimateSetId: Int)
            : Sequence&lt;BurdenEstimateOutcome&gt;
    {
        //check that the burden estimate set exists in the group etc
<span class="nc" id="L233">        val set = getBurdenEstimateSet(groupId, touchstoneVersionId, scenarioId, burdenEstimateSetId)</span>

<span class="nc bnc" id="L235" title="All 2 branches missed.">        if (set.isStochastic())</span>
        {
<span class="nc" id="L237">            throw InvalidOperationError(&quot;Cannot get burden estimate data for stochastic burden estimate sets&quot;)</span>
        }

<span class="nc" id="L240">        return dsl.select(</span>
<span class="nc" id="L241">                DISEASE.ID,</span>
<span class="nc" id="L242">                BURDEN_ESTIMATE.YEAR,</span>
<span class="nc" id="L243">                BURDEN_ESTIMATE.AGE,</span>
<span class="nc" id="L244">                COUNTRY.ID,</span>
<span class="nc" id="L245">                COUNTRY.NAME,</span>
<span class="nc" id="L246">                BURDEN_OUTCOME.CODE,</span>
<span class="nc" id="L247">                BURDEN_ESTIMATE.VALUE</span>
        )
<span class="nc" id="L249">                .fromJoinPath(BURDEN_ESTIMATE_SET, BURDEN_ESTIMATE)</span>
<span class="nc" id="L250">                .join(RESPONSIBILITY)</span>
<span class="nc" id="L251">                .on(BURDEN_ESTIMATE_SET.RESPONSIBILITY.eq(RESPONSIBILITY.ID))</span>
<span class="nc" id="L252">                .joinPath(RESPONSIBILITY, SCENARIO, SCENARIO_DESCRIPTION, DISEASE)</span>
<span class="nc" id="L253">                .join(COUNTRY)</span>
<span class="nc" id="L254">                .on(BURDEN_ESTIMATE.COUNTRY.eq(COUNTRY.NID))</span>
<span class="nc" id="L255">                .joinPath(BURDEN_ESTIMATE, BURDEN_OUTCOME)</span>
<span class="nc" id="L256">                .where(BURDEN_ESTIMATE_SET.ID.eq(burdenEstimateSetId))</span>
<span class="nc" id="L257">                .orderBy(</span>
<span class="nc" id="L258">                        DISEASE.ID,</span>
<span class="nc" id="L259">                        BURDEN_ESTIMATE.YEAR,</span>
<span class="nc" id="L260">                        BURDEN_ESTIMATE.AGE,</span>
<span class="nc" id="L261">                        COUNTRY.ID,</span>
<span class="nc" id="L262">                        COUNTRY.NAME,</span>
<span class="nc" id="L263">                        BURDEN_OUTCOME.CODE)</span>
<span class="nc" id="L264">                .fetchSequence()</span>
<span class="nc" id="L265">                .map { it.into(BurdenEstimateOutcome::class.java) }</span>

    }

    override fun getExpectedOutcomesForBurdenEstimateSet(burdenEstimateSetId: Int): List&lt;String&gt;
    {
<span class="nc" id="L271">        return dsl.select(BURDEN_ESTIMATE_OUTCOME_EXPECTATION.OUTCOME)</span>
<span class="nc" id="L272">                .from(BURDEN_ESTIMATE_SET)</span>
<span class="nc" id="L273">                .join(RESPONSIBILITY)</span>
<span class="nc" id="L274">                .on(BURDEN_ESTIMATE_SET.RESPONSIBILITY.eq(RESPONSIBILITY.ID))</span>
<span class="nc" id="L275">                .joinPath(RESPONSIBILITY, BURDEN_ESTIMATE_EXPECTATION, BURDEN_ESTIMATE_OUTCOME_EXPECTATION)</span>
<span class="nc" id="L276">                .where(BURDEN_ESTIMATE_SET.ID.eq(burdenEstimateSetId))</span>
<span class="nc" id="L277">                .groupBy(BURDEN_ESTIMATE_OUTCOME_EXPECTATION.OUTCOME)</span>
<span class="nc" id="L278">                .orderBy(BURDEN_ESTIMATE_OUTCOME_EXPECTATION.OUTCOME)</span>
<span class="nc" id="L279">                .fetch()</span>
<span class="nc" id="L280">                .getValues(BURDEN_ESTIMATE_OUTCOME_EXPECTATION.OUTCOME)</span>
    }

    override fun addModelRunParameterSet(groupId: String, touchstoneVersionId: String,
                                         modelVersionId: Int,
                                         modelRuns: List&lt;ModelRun&gt;,
                                         uploader: String, timestamp: Instant): Int
    {
        // We aren't checking whether the provided disease is associated with a scenario in this
        // responsibility set but the intention is to refactor the data model so that a responsibility set
        // is tied to a single disease, which will make this easier to do down the line
<span class="nc" id="L291">        val setId = getResponsibilitySetId(groupId, touchstoneVersionId)</span>

<span class="nc" id="L293">        return addModelRunParameterSet(setId,</span>
<span class="nc" id="L294">                modelVersionId, modelRuns, uploader, timestamp)</span>
    }

    private fun addModelRunParameterSet(responsibilitySetId: Int, modelVersionId: Int,
                                        modelRuns: List&lt;ModelRun&gt;,
                                        uploader: String, timestamp: Instant): Int
    {
<span class="nc" id="L301">        val uploadInfoId = addUploadInfo(uploader, timestamp)</span>
<span class="nc" id="L302">        val parameterSetId = addParameterSet(responsibilitySetId, modelVersionId, uploadInfoId)</span>
<span class="nc" id="L303">        val parameterLookup = addParameters(modelRuns, parameterSetId)</span>

<span class="nc bnc" id="L305" title="All 2 branches missed.">        for (run in modelRuns)</span>
        {
<span class="nc" id="L307">            addModelRun(run, parameterSetId, parameterLookup)</span>
        }

<span class="nc" id="L310">        return parameterSetId</span>
    }

    override fun getModelRunParameterSet(groupId: String, touchstoneVersionId: String, setId: Int): FlexibleDataTable&lt;ModelRun&gt;
    {
        //First check if this set id actually belongs to this group and touchstone version
<span class="nc" id="L316">        dsl.select(MODEL_RUN_PARAMETER_SET.ID)</span>
<span class="nc" id="L317">                .fromJoinPath(MODEL_RUN_PARAMETER_SET, RESPONSIBILITY_SET)</span>
<span class="nc" id="L318">                .where(MODEL_RUN_PARAMETER_SET.ID.eq(setId))</span>
<span class="nc" id="L319">                .and(RESPONSIBILITY_SET.MODELLING_GROUP.eq(groupId))</span>
<span class="nc" id="L320">                .and(RESPONSIBILITY_SET.TOUCHSTONE.eq(touchstoneVersionId))</span>
<span class="nc" id="L321">                .fetch()</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">                .singleOrNull() ?: throw UnknownObjectError(setId, &quot;model run parameter set&quot;)</span>

<span class="nc" id="L324">        val sequence = getModelRunParametersSequence(setId)</span>
<span class="nc" id="L325">        val headers = getModelRunParametersHeaders(setId)</span>

<span class="nc" id="L327">        return FlexibleDataTable.new(sequence, headers)</span>
    }

    private fun getModelRunParametersHeaders(setId: Int): List&lt;String&gt;
    {
<span class="nc" id="L332">        val records = dsl.select(</span>
<span class="nc" id="L333">                MODEL_RUN_PARAMETER.KEY</span>
        )
<span class="nc" id="L335">                .from(MODEL_RUN_PARAMETER)</span>
<span class="nc" id="L336">                .where(MODEL_RUN_PARAMETER.MODEL_RUN_PARAMETER_SET.eq(setId))</span>
<span class="nc" id="L337">                .fetchInto(String::class.java)</span>
<span class="nc" id="L338">        return records</span>
    }

    private fun getModelRunParametersSequence(setId: Int): Sequence&lt;ModelRun&gt;
    {
<span class="nc" id="L343">        return dsl.select(</span>
<span class="nc" id="L344">                MODEL_RUN_PARAMETER_VALUE.ID,</span>
<span class="nc" id="L345">                MODEL_RUN_PARAMETER.KEY,</span>
<span class="nc" id="L346">                MODEL_RUN.RUN_ID,</span>
<span class="nc" id="L347">                MODEL_RUN_PARAMETER_VALUE.VALUE</span>
        )
<span class="nc" id="L349">                .fromJoinPath(MODEL_RUN_PARAMETER, MODEL_RUN_PARAMETER_VALUE, MODEL_RUN)</span>
<span class="nc" id="L350">                .where(MODEL_RUN_PARAMETER.MODEL_RUN_PARAMETER_SET.eq(setId))</span>
<span class="nc" id="L351">                .fetch()</span>
<span class="nc" id="L352">                .map { mapper.mapModelRunParameter(it) }</span>
<span class="nc" id="L353">                .groupBy { it.run_id }</span>
<span class="nc" id="L354">                .map { mapper.mapModelRun(it.key, it.value) }</span>
<span class="nc" id="L355">                .asSequence()</span>
    }

    private fun addUploadInfo(uploader: String, timestamp: Instant): Int
    {
<span class="nc" id="L360">        val uploadInfo = dsl.newRecord(UPLOAD_INFO).apply {</span>
<span class="nc" id="L361">            this.uploadedBy = uploader</span>
<span class="nc" id="L362">            this.uploadedOn = Timestamp.from(timestamp)</span>
<span class="nc" id="L363">        }</span>

<span class="nc" id="L365">        uploadInfo.store()</span>

<span class="nc" id="L367">        return uploadInfo.id</span>
    }

    private fun addParameterSet(responsibilitySetId: Int, modelVersionId: Int,
                                uploadInfoId: Int): Int
    {
<span class="nc" id="L373">        val newParameterSet = this.dsl.newRecord(MODEL_RUN_PARAMETER_SET).apply {</span>
<span class="nc" id="L374">            this.responsibilitySet = responsibilitySetId</span>
<span class="nc" id="L375">            this.modelVersion = modelVersionId</span>
<span class="nc" id="L376">            this.uploadInfo = uploadInfoId</span>
<span class="nc" id="L377">        }</span>

<span class="nc" id="L379">        newParameterSet.store()</span>

<span class="nc" id="L381">        return newParameterSet.id</span>
    }

    private fun addParameters(modelRuns: List&lt;ModelRun&gt;, modelRunParameterSetId: Int): Map&lt;String, Int&gt;
    {
<span class="nc" id="L386">        val parameters = modelRuns.first().parameterValues.keys</span>
<span class="nc" id="L387">        return parameters.associateBy({ it }, {</span>
<span class="nc" id="L388">            val record = this.dsl.newRecord(MODEL_RUN_PARAMETER).apply {</span>
<span class="nc" id="L389">                this.key = it</span>
<span class="nc" id="L390">                this.modelRunParameterSet = modelRunParameterSetId</span>
<span class="nc" id="L391">            }</span>
<span class="nc" id="L392">            record.store()</span>
<span class="nc" id="L393">            record.id</span>
        })
    }

    private fun addModelRun(run: ModelRun, modelRunParameterSetId: Int, parameterIds: Map&lt;String, Int&gt;)
    {

<span class="nc" id="L400">        val record = this.dsl.newRecord(MODEL_RUN).apply {</span>
<span class="nc" id="L401">            this.runId = run.runId</span>
<span class="nc" id="L402">            this.modelRunParameterSet = modelRunParameterSetId</span>
<span class="nc" id="L403">        }</span>

<span class="nc" id="L405">        record.store()</span>

<span class="nc" id="L407">        run.parameterValues.map {</span>
<span class="nc" id="L408">            this.dsl.newRecord(MODEL_RUN_PARAMETER_VALUE).apply {</span>
<span class="nc" id="L409">                this.modelRun = record.internalId</span>
<span class="nc" id="L410">                this.modelRunParameter = parameterIds[it.key]</span>
<span class="nc" id="L411">                this.value = it.value</span>
<span class="nc" id="L412">            }.store()</span>
        }
<span class="nc" id="L414">    }</span>

    override fun clearBurdenEstimateSet(setId: Int, groupId: String, touchstoneVersionId: String, scenarioId: String)
    {
        // Dereference modelling group IDs
<span class="nc" id="L419">        val modellingGroup = modellingGroupRepository.getModellingGroup(groupId)</span>

        // make sure set belongs to responsibility
<span class="nc" id="L422">        val responsibilityInfo = getResponsibilityInfo(modellingGroup.id, touchstoneVersionId, scenarioId)</span>
<span class="nc" id="L423">        val set = getBurdenEstimateSetForResponsibility(setId, responsibilityInfo.id)</span>

<span class="nc bnc" id="L425" title="All 2 branches missed.">        if (set.status == BurdenEstimateSetStatus.COMPLETE)</span>
        {
<span class="nc" id="L427">            throw InvalidOperationError(&quot;You cannot clear a burden estimate set which is marked as 'complete'.&quot;)</span>
        }

        // We do this first, as this change will be rolled back if the annex
        // changes fail, but the reverse is not true
<span class="nc" id="L432">        changeBurdenEstimateStatus(setId, BurdenEstimateSetStatus.EMPTY)</span>
<span class="nc" id="L433">        getEstimateWriter(set).clearEstimateSet(setId)</span>
<span class="nc" id="L434">    }</span>

    override fun getEstimateWriter(set: BurdenEstimateSet): BurdenEstimateWriter
    {
<span class="nc bnc" id="L438" title="All 2 branches missed.">        return if (set.isStochastic())</span>
        {
<span class="nc" id="L440">            stochasticBurdenEstimateWriter</span>
        }
        else
        {
<span class="nc" id="L444">            centralBurdenEstimateWriter</span>
        }
    }

    override fun changeBurdenEstimateStatus(setId: Int, newStatus: BurdenEstimateSetStatus)
    {
<span class="nc" id="L450">        dsl.update(BURDEN_ESTIMATE_SET)</span>
<span class="nc" id="L451">                .set(BURDEN_ESTIMATE_SET.STATUS, mapper.mapEnum(newStatus))</span>
<span class="nc" id="L452">                .where(BURDEN_ESTIMATE_SET.ID.eq(setId))</span>
<span class="nc" id="L453">                .execute()</span>
<span class="nc" id="L454">    }</span>

    override fun updateCurrentBurdenEstimateSet(responsibilityId: Int, setId: Int, type: BurdenEstimateSetType)
    {
<span class="nc bnc" id="L458" title="All 2 branches missed.">        val field = if (type.isStochastic())</span>
        {
<span class="nc" id="L460">            RESPONSIBILITY.CURRENT_STOCHASTIC_BURDEN_ESTIMATE_SET</span>
        }
        else
        {
<span class="nc" id="L464">            RESPONSIBILITY.CURRENT_BURDEN_ESTIMATE_SET</span>
        }

<span class="nc" id="L467">        dsl.update(RESPONSIBILITY)</span>
<span class="nc" id="L468">                .set(field, setId)</span>
<span class="nc" id="L469">                .where(RESPONSIBILITY.ID.eq(responsibilityId))</span>
<span class="nc" id="L470">                .execute()</span>
<span class="nc" id="L471">    }</span>

    override fun createBurdenEstimateSet(responsibilityId: Int,
                                         modelVersionId: Int,
                                         properties: CreateBurdenEstimateSet,
                                         uploader: String,
                                         timestamp: Instant): Int
    {
<span class="nc" id="L479">        val setRecord = dsl.newRecord(BURDEN_ESTIMATE_SET).apply {</span>
<span class="nc" id="L480">            this.modelVersion = modelVersionId</span>
<span class="nc" id="L481">            this.responsibility = responsibilityId</span>
<span class="nc" id="L482">            this.uploadedBy = uploader</span>
<span class="nc" id="L483">            this.uploadedOn = Timestamp.from(timestamp)</span>
<span class="nc" id="L484">            this.runInfo = &quot;Not provided&quot;</span>
<span class="nc" id="L485">            this.interpolated = false</span>
<span class="nc" id="L486">            this.status = &quot;empty&quot;</span>
<span class="nc" id="L487">            this.setType = mapper.mapEnum(properties.type.type)</span>
<span class="nc" id="L488">            this.setTypeDetails = properties.type.details</span>
<span class="nc" id="L489">            this.modelRunParameterSet = properties.modelRunParameterSet</span>
<span class="nc" id="L490">        }</span>
<span class="nc" id="L491">        setRecord.insert()</span>
<span class="nc" id="L492">        return setRecord.id</span>
    }

    override fun getResponsibilityInfo(groupId: String, touchstoneVersionId: String, scenarioId: String): ResponsibilityInfo
    {
        // Get responsibility ID
<span class="nc" id="L498">        return dsl.select(RESPONSIBILITY.ID, SCENARIO_DESCRIPTION.DISEASE, RESPONSIBILITY_SET.STATUS, RESPONSIBILITY_SET.ID.`as`(&quot;setId&quot;))</span>
<span class="nc" id="L499">                .fromJoinPath(MODELLING_GROUP, RESPONSIBILITY_SET, RESPONSIBILITY, SCENARIO, SCENARIO_DESCRIPTION)</span>
<span class="nc" id="L500">                .joinPath(RESPONSIBILITY_SET, TOUCHSTONE)</span>
<span class="nc" id="L501">                .where(MODELLING_GROUP.ID.eq(groupId))</span>
<span class="nc" id="L502">                .and(TOUCHSTONE.ID.eq(touchstoneVersionId))</span>
<span class="nc" id="L503">                .and(SCENARIO_DESCRIPTION.ID.eq(scenarioId))</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">                .fetchOne()</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">                ?.into(ResponsibilityInfo::class.java)</span>
<span class="nc" id="L506">                ?: findMissingObjects(touchstoneVersionId, scenarioId)</span>
    }

    override fun updateBurdenEstimateSetFilename(setId: Int, filename: String?)
    {
<span class="nc" id="L511">        dsl.update(BURDEN_ESTIMATE_SET)</span>
<span class="nc" id="L512">                .set(BURDEN_ESTIMATE_SET.ORIGINAL_FILENAME, filename)</span>
<span class="nc" id="L513">                .where(BURDEN_ESTIMATE_SET.ID.eq(setId))</span>
<span class="nc" id="L514">                .execute()</span>
<span class="nc" id="L515">    }</span>

    private fun getResponsibilitySetId(groupId: String, touchstoneVersionId: String): Int
    {
        // Get responsibility ID
<span class="nc" id="L520">        return dsl.select(RESPONSIBILITY_SET.ID)</span>
<span class="nc" id="L521">                .fromJoinPath(MODELLING_GROUP, RESPONSIBILITY_SET, TOUCHSTONE)</span>
<span class="nc" id="L522">                .where(MODELLING_GROUP.ID.eq(groupId))</span>
<span class="nc" id="L523">                .and(TOUCHSTONE.ID.eq(touchstoneVersionId))</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">                .fetchOneInto(Int::class.java)</span>
<span class="nc" id="L525">                ?: throw UnknownObjectError(touchstoneVersionId, TouchstoneVersion::class)</span>
    }

    private fun &lt;T&gt; findMissingObjects(touchstoneVersionId: String, scenarioId: String): T
    {
<span class="nc" id="L530">        touchstoneRepository.touchstoneVersions.get(touchstoneVersionId)</span>
<span class="nc" id="L531">        scenarioRepository.checkScenarioDescriptionExists(scenarioId)</span>
        // Note this is where the scenario_description *does* exist, but
        // the group is not responsible for it in this touchstoneVersion
<span class="nc" id="L534">        throw UnknownObjectError(scenarioId, &quot;responsibility&quot;)</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>