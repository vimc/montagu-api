<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BurdenEstimateWriter.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">app</a> &gt; <a href="index.source.html" class="el_package">org.vaccineimpact.api.app.repositories.burdenestimates</a> &gt; <span class="el_source">BurdenEstimateWriter.kt</span></div><h1>BurdenEstimateWriter.kt</h1><pre class="source lang-java linenums">package org.vaccineimpact.api.app.repositories.burdenestimates

import org.jooq.DSLContext
import org.jooq.TableField
import org.jooq.impl.TableImpl
import org.postgresql.copy.CopyManager
import org.postgresql.core.BaseConnection
import org.vaccineimpact.api.app.awaitAndThrowIfError
import org.vaccineimpact.api.app.errors.DatabaseContentsError
import org.vaccineimpact.api.app.errors.InconsistentDataError
import org.vaccineimpact.api.app.errors.UnknownObjectError
import org.vaccineimpact.api.app.errors.UnknownRunIdError
import org.vaccineimpact.api.db.*
import org.vaccineimpact.api.models.BurdenEstimateWithRunId
import java.io.BufferedInputStream
import java.io.OutputStream
import java.io.PipedInputStream
import java.io.PipedOutputStream
import java.math.BigDecimal
import java.util.concurrent.Callable
import java.util.concurrent.Executors

<span class="nc" id="L23">abstract class BurdenEstimateWriter(</span>
        private val readDatabaseDSL: DSLContext,
        private val writeDatabaseDSLSource: CloseableContext
)
{
    abstract val table: TableImpl&lt;*&gt;
    protected abstract val fields: List&lt;TableField&lt;*, *&gt;&gt;
    abstract val setField: TableField&lt;*, Int&gt;

    open fun addEstimatesToSet(setId: Int, estimates: Sequence&lt;BurdenEstimateWithRunId&gt;, expectedDisease: String)
    {
<span class="nc" id="L34">        val countryLookup = getCountriesAsLookup()</span>
<span class="nc" id="L35">        val outcomeLookup = getOutcomesAsLookup()</span>
<span class="nc" id="L36">        val modelRuns = getModelRunsAsLookup(setId)</span>
<span class="nc" id="L37">        val modelRunParameterId = getModelRunParameterSetId(setId)</span>
<span class="nc" id="L38">        writeDatabaseDSLSource.inside { writeDatabaseDSL -&gt;</span>
            // The only foreign keys are:
            // * burden_estimate_set, which is the same for every row, and it's the one we just created and know exists
            // * country, which we check below, per row of the CSV (and each row represents multiple rows in the database
            //   so this is an effort saving).
            // * burden_outcome, which we check below (currently we check for every row, but given these are set in the
            //   columns and don't vary by row this could be made more efficient)
<span class="nc" id="L45">            writeDatabaseDSL.withoutCheckingForeignKeyConstraints(table) {</span>

<span class="nc" id="L47">                PipedOutputStream().use { stream -&gt;</span>
                    // First, let's set up a thread to read from the stream and send
                    // it to the database. This will block if the thread is empty, and keep
                    // going until it sees the Postgres EOF marker.
<span class="nc bnc" id="L51" title="All 2 branches missed.">                    val inputStream = PipedInputStream(stream).buffered()</span>
                    // TODO: Use a real thread pool
<span class="nc" id="L53">                    val executor = Executors.newSingleThreadExecutor()</span>
<span class="nc" id="L54">                    val writeToDatabaseFuture = executor.submit(writeStreamToDatabase(inputStream, writeDatabaseDSL))</span>

<span class="nc" id="L56">                    try</span>
                    {
                        // In the main thread, write to piped stream, blocking if we get too far ahead of
                        // the other thread (&quot;too far ahead&quot; meaning the buffer on the input stream is full)
<span class="nc" id="L60">                        writeCopyData(</span>
<span class="nc" id="L61">                                outcomeLookup,</span>
<span class="nc" id="L62">                                countryLookup,</span>
<span class="nc" id="L63">                                modelRuns,</span>
<span class="nc" id="L64">                                modelRunParameterId,</span>
<span class="nc" id="L65">                                stream,</span>
<span class="nc" id="L66">                                estimates,</span>
<span class="nc" id="L67">                                expectedDisease,</span>
<span class="nc" id="L68">                                setId)</span>
                    }
                    finally
                    {
                        // Wait for the worker thread to finish
<span class="nc" id="L73">                        writeToDatabaseFuture.awaitAndThrowIfError()</span>
                    }
<span class="nc" id="L75">                }</span>
<span class="nc" id="L76">            }</span>
<span class="nc" id="L77">        }</span>
<span class="nc" id="L78">    }</span>

    open fun clearEstimateSet(setId: Int)
    {
<span class="nc" id="L82">        writeDatabaseDSLSource.inside { dsl -&gt;</span>
<span class="nc" id="L83">            dsl.deleteFrom(table).where(setField.eq(setId)).execute()</span>
<span class="nc" id="L84">        }</span>
<span class="nc" id="L85">    }</span>

    open fun isSetEmpty(setId: Int): Boolean
    {
<span class="nc bnc" id="L89" title="All 2 branches missed.">        return readDatabaseDSL.fetchAny(table, setField.eq(setId)) == null</span>
    }

    private fun writeCopyData(
            outcomeLookup: Map&lt;String, Short&gt;,
            countries: Map&lt;String, Short&gt;,
            modelRuns: Map&lt;String, Int&gt;,
            modelRunParameterSetId: Int?,
            stream: OutputStream,
            estimates: Sequence&lt;BurdenEstimateWithRunId&gt;,
            expectedDisease: String,
            setId: Int
    )
    {
        // When we exit the 'use' block the EOF character will be written out,
        // signalling to the other thread that we are done.
<span class="nc" id="L105">        PostgresCopyWriter(stream).use { writer -&gt;</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">            val cohortSizeId = outcomeLookup[&quot;cohort_size&quot;]</span>
<span class="nc" id="L107">                    ?: throw DatabaseContentsError(&quot;Expected a value with code 'cohort_size' in burden_outcome table&quot;)</span>

<span class="nc bnc" id="L109" title="All 2 branches missed.">            for (estimate in estimates)</span>
            {
<span class="nc bnc" id="L111" title="All 2 branches missed.">                if (estimate.disease != expectedDisease)</span>
                {
<span class="nc" id="L113">                    throw InconsistentDataError(&quot;Provided estimate lists disease as '${estimate.disease}' but scenario is for disease '$expectedDisease'&quot;)</span>
                }
<span class="nc bnc" id="L115" title="All 2 branches missed.">                val countryId = countries[estimate.country]</span>
<span class="nc" id="L116">                    ?: throw UnknownObjectError(estimate.country, &quot;country&quot;)</span>
<span class="nc" id="L117">                val modelRun = resolveRunId(modelRuns, modelRunParameterSetId, estimate.runId)</span>

<span class="nc" id="L119">                writer.writeRow(newBurdenEstimateRow(setId, modelRun, estimate, countryId, cohortSizeId, estimate.cohortSize))</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">                for (outcome in estimate.outcomes)</span>
                {
<span class="nc bnc" id="L122" title="All 2 branches missed.">                    val outcomeId = outcomeLookup[outcome.key]</span>
<span class="nc" id="L123">                            ?: throw UnknownObjectError(outcome.key, &quot;burden-outcome&quot;)</span>
<span class="nc" id="L124">                    writer.writeRow(newBurdenEstimateRow(setId, modelRun, estimate, countryId, outcomeId, outcome.value))</span>
                }
            }
<span class="nc" id="L127">        }</span>
<span class="nc" id="L128">    }</span>

    private fun newBurdenEstimateRow(
            setId: Int,
            modelRun: Int?,
            estimate: BurdenEstimateWithRunId,
            countryId: Short,
            outcomeId: Short,
            outcomeValue: Float?
    ): List&lt;Any?&gt;
    {
<span class="nc" id="L139">        return listOf(</span>
<span class="nc" id="L140">                setId,</span>
<span class="nc" id="L141">                modelRun,</span>
<span class="nc" id="L142">                countryId,</span>
<span class="nc" id="L143">                estimate.year,</span>
<span class="nc" id="L144">                estimate.age,</span>
<span class="nc" id="L145">                outcomeId,</span>
<span class="nc" id="L146">                outcomeValue</span>
        )
    }

    private fun resolveRunId(modelRuns: Map&lt;String, Int&gt;, modelRunParameterSetId: Int?, runId: String?): Int?
    {
        // If we are expecting run IDs not to be null (i.e. for stochastic estimates)
        // we expect this to have been caught at an earlier stage, during CSV parsing
<span class="nc bnc" id="L154" title="All 2 branches missed.">        return if (runId == null)</span>
        {
<span class="nc" id="L156">            null</span>
        }
        else
        {
<span class="nc bnc" id="L160" title="All 2 branches missed.">            modelRuns.getOrDefault(runId, null)</span>
<span class="nc" id="L161">                    ?: throw UnknownRunIdError(runId, modelRunParameterSetId)</span>
        }
    }

    private fun getModelRunParameterSetId(setId: Int): Int? =
<span class="nc" id="L166">            readDatabaseDSL.select(Tables.BURDEN_ESTIMATE_SET.MODEL_RUN_PARAMETER_SET)</span>
<span class="nc" id="L167">                    .from(Tables.BURDEN_ESTIMATE_SET)</span>
<span class="nc" id="L168">                    .where(Tables.BURDEN_ESTIMATE_SET.ID.eq(setId))</span>
<span class="nc" id="L169">                    .fetch()</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">                    .singleOrNull()?.value1()</span>

<span class="nc" id="L172">    private fun getCountriesAsLookup(): Map&lt;String, Short&gt; = readDatabaseDSL.select(Tables.COUNTRY.ID, Tables.COUNTRY.NID)</span>
<span class="nc" id="L173">            .from(Tables.COUNTRY)</span>
<span class="nc" id="L174">            .fetch()</span>
<span class="nc" id="L175">            .intoMap(Tables.COUNTRY.ID, Tables.COUNTRY.NID)</span>

    private fun getOutcomesAsLookup(): Map&lt;String, Short&gt;
    {
<span class="nc" id="L179">        return readDatabaseDSL.select(Tables.BURDEN_OUTCOME.CODE, Tables.BURDEN_OUTCOME.ID)</span>
<span class="nc" id="L180">                .from(Tables.BURDEN_OUTCOME)</span>
<span class="nc" id="L181">                .fetch()</span>
<span class="nc" id="L182">                .intoMap(Tables.BURDEN_OUTCOME.CODE, Tables.BURDEN_OUTCOME.ID)</span>
    }

    private fun getModelRunsAsLookup(setId: Int): Map&lt;String, Int&gt;
    {
        // This gets us from user defined run IDs (e.g. &quot;run_with_extra_toffee&quot;)
        // to our auto-generated internal IDs (e.g. 4532)
<span class="nc" id="L189">        return readDatabaseDSL.select(Tables.MODEL_RUN.INTERNAL_ID, Tables.MODEL_RUN.RUN_ID)</span>
<span class="nc" id="L190">                .fromJoinPath(Tables.BURDEN_ESTIMATE_SET, Tables.MODEL_RUN_PARAMETER_SET, Tables.MODEL_RUN)</span>
<span class="nc" id="L191">                .where(Tables.BURDEN_ESTIMATE_SET.ID.eq(setId))</span>
<span class="nc" id="L192">                .fetch()</span>
<span class="nc" id="L193">                .map { it[Tables.MODEL_RUN.RUN_ID] to it[Tables.MODEL_RUN.INTERNAL_ID] }</span>
<span class="nc" id="L194">                .toMap()</span>
    }

    private fun writeStreamToDatabase(
            inputStream: BufferedInputStream,
            writeDatabaseDSL: DSLContext
    ): Callable&lt;Exception?&gt;
    {
        // Since we are in another thread here, we should be careful about what state we modify.
        // Everything we have access to here is immutable, so we should be fine.
<span class="nc" id="L204">        return Callable({</span>
<span class="nc" id="L205">            try</span>
            {
                // We use dsl.connection to drop down from jOOQ to the JDBC level so we can use CopyManager.
<span class="nc" id="L208">                writeDatabaseDSL.connection { connection -&gt;</span>
<span class="nc" id="L209">                    val manager = CopyManager(connection as BaseConnection)</span>
                    // This will return once it reaches the EOF character written out by the other stream
<span class="nc" id="L211">                    manager.copyInto(table, inputStream, fields)</span>
<span class="nc" id="L212">                }</span>
<span class="nc" id="L213">                null</span>
            }
            catch (e: Exception)
<span class="nc" id="L216">            {</span>
<span class="nc" id="L217">                inputStream.close()</span>
<span class="nc" id="L218">                e</span>
<span class="nc" id="L219">            }</span>
        })
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>